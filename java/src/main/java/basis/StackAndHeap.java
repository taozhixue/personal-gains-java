package basis;

/**
 * 
 * 栈stack  堆heap
 *
 */
public class StackAndHeap {
	/**
	 * 栈stack
	 */
	/**
	 * 2. 栈的优势是，存取速度比堆要快，仅次于直接位于CPU中的寄存器。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。
	 * 另外，栈数据可以共享，详见第3点。堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，Java的垃圾收集器会自动收走这些不再使用的数据。
	 * 但缺点是，由于要在运行时动态分配内存，存取速度较慢。 
	 */
	
	/**
	 * 基本类型(primitive types), 共有8种，即int, short, long, byte, float, double, boolean, char
	 * (注意，并没有string的基本类型)。这种类型的定义是通过诸如int a = 3; long b = 255L;的形式来定义的，称为自动变量。
	 * 值得注意的是，自动变量存的是字面值，不是类的实例，即不是类的引用，这里并没有类的存在。如int a = 3; 
	 * 这里的a是一个指向int类型的引用，指向3这个字面值。这些字面值的数据，由于大小可知，生存期可知(这些字面值固定定义在某个程序块里面，程序块退出后，
	 * 字段值就消失了)，出于追求速度的原因，就存在于栈中。
	 */
	
	/**
	 * 存在栈中的数据可以共享
	 */
	
	/**
	 * 这种字面值的引用与类对象的引用不同。假定两个类对象的引用同时指向一个对象，如果一个对象引用变量修改了这个对象的内部状态，
	 * 那么另一个对象引用变量也即刻反映出这个变化。相反，通过字面值的引用来修改其值，不会导致另一个指向此字面值的引用的值也跟着改变的情况。
	 * 如上例，我们定义完a与b的值后，再令a=4；那么，b不会等于4，还是等于3。在编译器内部，遇到a=4；时，它就会重新搜索栈中是否有4的字面值，
	 * 如果没有，重新开辟地址存放4的值；如果已经有了，则直接将a指向这个地址。因此a值的改变不会影响到b的值。
	 */
	
	/**
	 * 另一种是包装类数据，如Integer, String, Double等将相应的基本数据类型包装起来的类。这些类数据全部存在于堆中，
	 * Java用new()语句来显示地告诉编译器，在运行时才根据需要动态创建，因此比较灵活，但缺点是要占用更多的时间。 4.
	 *  String是一个特殊的包装类数据。即可以用String str = new String("abc");的形式来创建，也可以用String str = "abc"；
	 *  的形式来创建(作为对比，在JDK 5.0之前，你从未见过Integer i = 3;的表达式，因为类与字面值是不能通用的，除了String。
	 *  而在JDK 5.0中，这种表达式是可以的！因为编译器在后台进行Integer i = new Integer(3)的转换)。
	 *  前者是规范的类的创建过程，即在Java中，一切都是对象，而对象是类的实例，全部通过new()的形式来创建。Java中的有些类，
	 *  如DateFormat类，可以通过该类的getInstance()方法来返回一个新创建的类，似乎违反了此原则。其实不然。该类运用了单例模式来返回类的实例，
	 *  只不过这个实例是在该类内部通过new()来创建的，而getInstance()向外部隐藏了此细节。那为什么在String str = "abc"；中，
	 *  并没有通过new()来创建实例，是不是违反了上述原则？其实没有。 
	 */
	
	/**
	 * 关于String str = "abc"的内部工作。Java内部将此语句转化为以下几个步骤：
		(1)先定义一个名为str的对String类的对象引用变量：String str；
		(2)在栈中查找有没有存放值为"abc"的地址，如果没有，则开辟一个存放字面值为"abc"的地址，接着创建一个新的String类的对象o，
		并将o的字符串值指向这个地址，而且在栈中这个地址旁边记下这个引用的对象o。如果已经有了值为"abc"的地址，则查找对象o，并返回o的地址。
		(3)将str指向对象o的地址。 
	 */
	/**
	 * String str1 = "abc";
		String str2 = "abc";
		str1 = "bcd";
		System.out.println(str1 + "," + str2); //bcd, abc
		System.out.println(str1==str2); //false
		这就是说，赋值的变化导致了类对象引用的变化，str1指向了另外一个新对象！而str2仍旧指向原来的对象。上例中，当我们将str1的值改为"bcd"时，
		JVM发现在栈中没有存放该值的地址，便开辟了这个地址，并创建了一个新的对象，其字符串的值指向这个地址。 
	 */
	
	/**
	 * 栈：基本类型的变量和对象的引用变量
	 * 堆：由new创建的对象和数组
	 * 栈中的变量指向堆内存中的变量，这就是 Java 中的指针!
	 * 堆主要用来存放对象的，栈主要是用来执行程序的
	 * 在函数中定义的一些基本类型的变量和对象的引用变量都在函数的栈内存中分配。 
	 * 引用变量就相当于是为数组或对象起的一个名称，以后就可以在程序中使用栈中的引用变量来访问堆中的数组或对象。
	 * http://blog.csdn.net/chengyingzhilian/article/details/7781858
	 * 
	 */
}
